package com.hedza06.camttl.services;import lombok.extern.slf4j.Slf4j;import org.camunda.bpm.engine.HistoryService;import org.camunda.bpm.engine.history.HistoricProcessInstance;import org.joda.time.DateTime;import org.springframework.beans.factory.annotation.Value;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;@Slf4j@Servicepublic class CustomCleanupHistoryService {    @Value("${history-cleanup.uri}")    private String cleanUpUri;    private final HistoryService historyService;    private final RestTemplate restTemplate;    public CustomCleanupHistoryService(HistoryService historyService)    {        this.historyService = historyService;        this.restTemplate = new RestTemplate();    }    /**     * Clean historic instances by removal time (async)     */    public void cleanHistoryByRemovalTimeAsync() {        historyService.cleanUpHistoryAsync();    }    /**     * Clean exceeded instances with removal time     */    public void cleanByExceededInstanceRemovalTime()    {        log.info("Fetching historic process instances...");        List<HistoricProcessInstance> historicInstances = historyService            .createHistoricProcessInstanceQuery()            .finished()            .list();        if (historicInstances != null && !historicInstances.isEmpty())        {            log.info("Fetched {} instances for cleanup!", historicInstances.size());            List<String> instanceIdentifiers = historicInstances.stream()                .filter(historicInstance -> historicInstance.getRemovalTime() != null)                .filter(historicInstance                    -> new DateTime(historicInstance.getRemovalTime()).withTimeAtStartOfDay()                        .isBefore(new DateTime().withTimeAtStartOfDay()))                .map(historicInstance ->                    historicInstance.getSuperProcessInstanceId() != null                        ? historicInstance.getSuperProcessInstanceId()                        : historicInstance.getRootProcessInstanceId()                ).collect(Collectors.toList());            if (!instanceIdentifiers.isEmpty())            {                log.info("Cleanup started...");                invokeCleanupForInstances(instanceIdentifiers);                log.info("Cleanup done!");            }        }    }    /**     * Invoke cleanup for target instances     *     * @param processInstances historic process instance identifiers     */    private void invokeCleanupForInstances(List<String> processInstances)    {        List<String> unprocessedInstances = new ArrayList<>();        HttpEntity<Void> requestEntity = new HttpEntity<>(generateHeaders());        for (String processInstance : processInstances)        {            String targetUri = cleanUpUri.concat("/").concat(processInstance);            try            {                ResponseEntity<Void> responseEntity = restTemplate.exchange(                    targetUri, HttpMethod.DELETE, requestEntity, Void.class                );                if (!responseEntity.getStatusCode().equals(HttpStatus.NO_CONTENT)) {                    unprocessedInstances.add(processInstance);                }            }            catch (Exception e) {                unprocessedInstances.add(processInstance);            }        }        log.info("Report about cleanup:");        log.info("Number of processed instances: {}", processInstances.size());        log.info("Number of un-processed instances: {}", unprocessedInstances.size());        log.info("---------------- Statistics -----------------");        unprocessedInstances.forEach(identifier -> log.info("Un-processed instance id: {}", identifier));    }    /**     * Generate Http Headers for CAM cleanup     *     * @return HttpHeaders Object     */    private HttpHeaders generateHeaders()    {        HttpHeaders httpHeaders = new HttpHeaders();        httpHeaders.setContentType(MediaType.APPLICATION_JSON);        return httpHeaders;    }}